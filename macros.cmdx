! A.Mereghetti, 2021-01-19
! a file collecting MADX macros

! general aperture outside magnets
aper1=0.0; ! [m]
aper2=0.0; ! [m]
aper3=0.0; ! [m]
aper4=0.0; ! [m]
CNAO_APE: MARKER, APERTYPE=RECTANGLE, APERTURE={aper1,aper2,aper3,aper4};
! longitudinal shift of added apertures
tmpD=0.0; ! [m]

! add aperture markers upstream/downstream of a given element
! NB: aperType and aper1,aper2,aper3,aper4 and offx,offy should be defined before calling the macro;
addAperture(eleName,apeType): macro = {
   eleName, APERTYPE=apeType, APERTURE={aper1,aper2,aper3,aper4}, APER_OFFSET={offx,offy};
   eleName_EN: MARKER, APERTYPE=apeType, APERTURE={aper1,aper2,aper3,aper4}, APER_OFFSET={offx,offy};
   eleName_EX: MARKER, APERTYPE=apeType, APERTURE={aper1,aper2,aper3,aper4}, APER_OFFSET={offx,offy};
   SEQEDIT, sequence=MUXL;
   Install, element=eleName_EN, at=-0.5*eleName->L-  tmpD, from=eleName;
   Install, element=CNAO_APE  , at=-0.5*eleName->L-2*tmpD, from=eleName;
   Install, element=CNAO_APE  , at= 0.5*eleName->L+2*tmpD, from=eleName;
   Install, element=eleName_EX, at= 0.5*eleName->L+  tmpD, from=eleName;
   ENDEDIT;
};

! save a .tfs file with linear optics functions in a specific column order
! please specify if the sequence is in thin or thick lens (is_thin<>0).
! in case of an open line (e.g. a transfer line, the gantry, etc...), use
!    initial conditions to linear optics functions (flagged as initial).
saveOpticsTFS(fileName): macro = {
   select,flag=twiss,clear;
   select,flag=twiss,column=name,keyword,l,s,betx,alfx,bety,alfy,x,px,y,py,dx,dpx,dy,dpy,mux,muy;
   if (is_open<>0) {
      ! a transfer line: we need the initial conditions
      if (is_thin>0) {
         twiss, rmatrix=true, file=fileName_optics_thin.tfs, beta0=initial;
      } else {
         twiss, rmatrix=true, file=fileName_optics.tfs, beta0=initial;
      };
   } else {
      ! a ring: optics is computed as self-consisten solution
      if (is_thin>0) {
         twiss, rmatrix=true, file=fileName_optics_thin.tfs;
      } else {
         twiss, rmatrix=true, file=fileName_optics.tfs;
      };
   };
};

! save a .tfs file with geometry infos (strengths, aperture, etc...) in a specific column order
! please specify if the sequence is in thin or thick lens (is_thin<>0).
! in case of an open line (e.g. a transfer line, the gantry, etc...), use
!    initial conditions to linear optics functions (flagged as initial).
saveGeometryTFS(fileName): macro = {
   select,flag=twiss,clear;
   select,flag=twiss,column=name,keyword,l,s,kick,hkick,vkick,angle,k0l,k1l,k2l,apertype,aper_1,aper_2,aper_3,aper_4,apoff_1,apoff_2;
   if (is_open<>0) {
      ! a transfer line: we need the initial conditions
      if (is_thin>0) {
         twiss, rmatrix=true, file=fileName_geometry_thin.tfs, beta0=initial;
      } else {
         twiss, rmatrix=true, file=fileName_geometry.tfs, beta0=initial;
      };
   } else {
      ! a ring: optics is computed as self-consisten solution
      if (is_thin>0) {
         twiss, rmatrix=true, file=fileName_geometry_thin.tfs;
      } else {
         twiss, rmatrix=true, file=fileName_geometry.tfs;
      };
   };
};

! save a .tfs file with main elements of R matrix, at centre of thick elements!
! please specify if the sequence is in thin or thick lens (is_thin<>0).
! in case of an open line (e.g. a transfer line, the gantry, etc...), use
!    initial conditions to linear optics functions (flagged as initial).
saveRmatrixTFS(fileName): macro = {
   select,flag=twiss,clear;
   select,flag=twiss,column=name,keyword,l,s,re11,re12,re21,re22,re16,re26,re33,re34,re43,re44,re36,re46,re51,re52,re55,re56,re66;
   if (is_open<>0) {
      ! a transfer line: we need the initial conditions
      if (is_thin>0) {
         twiss, rmatrix=true, centre=true, file=fileName_Rmatrix_thin.tfs, beta0=initial;
      } else {
         twiss, rmatrix=true, centre=true, file=fileName_Rmatrix.tfs, beta0=initial;
      };
   } else {
      ! a ring: optics is computed as self-consisten solution
      if (is_thin>0) {
         twiss, rmatrix=true, centre=true, file=fileName_Rmatrix_thin.tfs;
      } else {
         twiss, rmatrix=true, centre=true, file=fileName_Rmatrix.tfs;
      };
   };
};

! save an apic.txt file
! please specify if the sequence is in thin or thick lens (is_thin<>0).
! in case of an open line (e.g. a transfer line, the gantry, etc...), use
!    initial conditions to linear optics functions (flagged as initial).
saveAPIC(): macro = {
   select,flag=twiss,clear;
   select,flag=twiss,COLUMN=NAME, KEYWORD, L, TILT, ANGLE, E1, E2, K1L, K2L, K3L, KS;
   if (is_open<>0) {
      ! a transfer line: we need the initial conditions
      twiss, rmatrix=true, file=apic.txt, beta0=initial;
   } else {
      ! a ring: optics is computed as self-consisten solution
      twiss, rmatrix=true, file=apic.txt;
   };
};

! save a .tfs file with linear optics functions in a specific column order
! the column order is the same as that of the saveGeometryTFS macro, apart from
!    the very frist columns
! the optics functions are computed at a specific element in the context of a current scan
saveOpticsTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINTF, TEXT="% 19.12E,% 6.1f,% 6.0f,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E",
         VALUE=Brho, BP, myID,
         table(twiss,eleName,BETX),table(twiss,eleName,ALFX),table(twiss,eleName,BETY),table(twiss,eleName,ALFY),
         table(twiss,eleName,X),table(twiss,eleName,PX),table(twiss,eleName,Y),table(twiss,eleName,PY),
         table(twiss,eleName,DX),table(twiss,eleName,DPX),table(twiss,eleName,DY),table(twiss,eleName,DPY),
         table(twiss,eleName,MUX),table(twiss,eleName,MUY);
   assign, echo=terminal;
};
headOpticsTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINT, TEXT=# Brho[Tm], BP[mm], ID[],
   BETX[m]:eleName, ALFX[]:eleName, BETY[m]:eleName, ALFY[]:eleName,
   X[m]:eleName, PX[]:eleName, Y[m]:eleName, PY[]:eleName,
   DX[m]:eleName, DPX[]:eleName, DY[m]:eleName, DPY[]:eleName,
   MUX[2pi]:eleName, MUY[2pi]:eleName;
   assign, echo=terminal;
};

! save a .tfs file with geometry infos (strengths, aperture, etc...) in a specific column order
! the column order is the same as that of the saveGeometryTFS macro, apart from
!    the very frist columns
! the optics functions are computed at a specific element in the context of a current scan
saveGeometryTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINTF, TEXT="% 19.12E,% 6.1f,% 6.0f,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,%-19s,%12.4f,%12.4f,%12.4f,%12.4f,% 12.4f,% 12.4f",
         VALUE=Brho, BP, myID,
         eleName->KICK,eleName->HKICK,eleName->VKICK,eleName->ANGLE,
		 eleName->K0*eleName->L,eleName->K1*eleName->L,eleName->K2*eleName->L,
		 eleName->APERTYPE,eleName->APER_1,eleName->APER_2,eleName->APER_3,eleName->APER_4,eleName->APOFF_1,eleName->APOFF_2;
   assign, echo=terminal;
};
headGeometryTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINT, TEXT=# Brho[Tm], BP[mm], ID[],
   KICK[rad]:eleName, HKICK[rad]:eleName, VKICK[rad]:eleName, ANGLE[rad]:eleName,
   K0L[rad]:eleName, K1L[rad/m]:eleName, K2L[rad/m2]:eleName,
   APERTYPE[]:eleName, APER_1[m]:eleName, APER_2[m]:eleName, APER_3[m]:eleName, APER_4[m]:eleName, APOFF_1[m]:eleName, APOFF_2[m]:eleName;
   assign, echo=terminal;
};

! save a .tfs file with main elements of R matrix in a specific column order
! the column order is the same as that of the saveRmatrixTFS macro, apart from
!    the very frist columns
! the optics functions are computed at a specific element in the context of a current scan
saveRmatrixTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINTF, TEXT="% 19.12E,% 6.1f,% 6.0f,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E,% 19.12E",
         VALUE=Brho, BP, myID,
         table(twiss,eleName,RE11),table(twiss,eleName,RE12),table(twiss,eleName,RE21),table(twiss,eleName,RE22),table(twiss,eleName,RE16),table(twiss,eleName,RE26),
         table(twiss,eleName,RE33),table(twiss,eleName,RE34),table(twiss,eleName,RE43),table(twiss,eleName,RE44),table(twiss,eleName,RE36),table(twiss,eleName,RE46),
         table(twiss,eleName,RE51),table(twiss,eleName,RE52),table(twiss,eleName,RE55),table(twiss,eleName,RE56),table(twiss,eleName,RE66);
   assign, echo=terminal;
};
headRmatrixTFSatEle(fileName,eleName): macro = {
   assign, echo=fileName;
   PRINT, TEXT=# Brho[Tm], BP[mm], ID[],
   RE11[]:eleName, RE12[m]:eleName, RE21[rad]:eleName, RE22[]:eleName, RE16[m]:eleName, RE26[rad]:eleName,
   RE33[]:eleName, RE34[m]:eleName, RE43[rad]:eleName, RE44[]:eleName, RE36[m]:eleName, RE46[rad]:eleName,
   RE51[s m-1]:eleName, RE52[s rad-1]:eleName, RE55[]:eleName, RE56[s]:eleName, RE66[m]:eleName;
   assign, echo=terminal;
};

! insert a thin kicker up/dostream of a specific element
surroundKICKER(MagName,SeqName): macro={
	MagName->HKICK=0.0; MagName->VKICK=0.0;
	MagNamePRIMA: KICKER, L= 0.0, HKICK := MagName_HKICK/2, VKICK := MagName_VKICK/2;
	MagNameDOPO:  KICKER, L= 0.0, HKICK := MagName_HKICK/2, VKICK := MagName_VKICK/2;
	SEQEDIT, sequence=SeqName;
	Install, element=MagNamePRIMA, at=-0.5*MagName->L, from=MagName;
	Install, element=MagNameDOPO , at= 0.5*MagName->L, from=MagName;
	ENDEDIT;
};
surroundMBEND(MagName,SeqName): macro={
	MagName->ANGLE=0.0; MagName->K0=0.0;
	MagNamePRIMA: KICKER, L= 0.0, HKICK := MagName_ANGLE/2;
	MagNameDOPO:  KICKER, L= 0.0, HKICK := MagName_ANGLE/2;
	SEQEDIT, sequence=SeqName;
	Install, element=MagNamePRIMA, at=-0.5*MagName->L, from=MagName;
	Install, element=MagNameDOPO , at= 0.5*MagName->L, from=MagName;
	ENDEDIT;
};

! set beam rigidity and other realtivistic quantities based on beam energy
setRigidity(): macro = {
   ! input:
   ! - Ek [MeV/n]: kinetic energy per nucleon;
   ! - A0,Z0 []: nuclear mass, atomic number;
   ! - m0 [MeV]: rest mass;
   gammaRel=(Ek*A0)/m0+1;
   betaGammaRel=sqrt(gammaRel^2-1);
   betaRel=betaGammaRel/gammaRel;
   Brho=betaGammaRel*m0/(CLIGHT*1E-6*Z0);
   ! value, Ek, A0, m0, gammaRel, betaGammaRel, betaRel, Brho;
};

setBeam(mySequence): macro = {
   ! AM: set crazy energies, otherwise dispersion will be divided by beta_rel...
   beam, particle=proton, energy=1000, sequence=mySequence;
   
   if ( is_carbon == 0 ) {
     ! properties of protons
     A0=1;         ! []
     Z0=1;         ! []
     m0=PMASS*1E3; ! [MeV]
     ! m0=938.255; ! rampGen [MeV]
   } else {
     ! protperties of carbon ions
     A0=12;           ! []
     Z0=6;            ! []
     m0=A0*NMASS*1E3; ! [MeV]
   };
};

! save Rmatrix at specific element
! NB: please remember to use and twiss your sequence beforehand, e.g.:
!     use, sequence=gantry;
!     twiss, table=twiss, rmatrix=true, beta0=initial; 
save_RMatrix(eleName): macro = {
  REMOVEFILE, FILE="Rmatrix.txt";
  assign, echo="Rmatrix.txt";
  PRINTF, TEXT="#  | % 23.0f % 23.0f % 23.0f % 23.0f % 23.0f % 23.0f", VALUE=1,2,3,4,5,6;
  PRINTF, TEXT="#--|------------------------------------------------------------------------------------------------------------------------------------------------", VALUE=0;
  n=1;
  WHILE (n<=6) {
    exec, save_RMatrix_iLine(eleName,$n);
    n=n+1;
  };
  assign, echo=terminal;
};

save_RMatrix_iLine(eleName,iLine): macro = {
  PRINTF, TEXT="%2.0f | % 23.16E % 23.16E % 23.16E % 23.16E % 23.16E % 23.16E",
      VALUE=iLine,table(twiss,eleName,reiLine1),table(twiss,eleName,reiLine2),table(twiss,eleName,reiLine3),
                  table(twiss,eleName,reiLine4),table(twiss,eleName,reiLine5),table(twiss,eleName,reiLine6);
};

show_kIVals_element(eleName): macro = {
  tmpK0=eleName->ANGLE/eleName->L;
  PRINTF, TEXT=eleName % 24.16E % 24.16E % 24.16E % 24.16E, VALUE=tmpK0,tmpK0*Brho,eleName->K1,eleName->K1*Brho;
};

save_strengths(fileName,beamLine): macro = {
   ! beamLine: MEBT, synchro, HEBT;
   REMOVEFILE, FILE=fileName.str;
   assign, echo=filename.str;
   print, TEXT="! general infos:";
   print, TEXT="! - kinetick energy [MeV/n]";
   print, TEXT="! - Range [mm]";
   value, Ek;
   value, Bp;
   exec, save_strengths_beamLine();
   assign, echo=terminal;
};

insertMarkerUpstreamOf(MyMarkerName,UpEleName,MySeqName): macro = {
   SEQEDIT, SEQUENCE=MySeqName;
   INSTALL, ELEMENT=MyMarkerName, CLASS=MARKER, AT=-0.5*UpEleName->L, FROM=UpEleName;
   ENDEDIT;
};

! convert current into K1, using a linear dependence
I2K_QUs_lin(MagName,biro) : macro {
  ! the macro expects IMagName, KMagName and FMagName to be defined
  ! eg. H2_012A_QUE -> I_H2_012A_QUE, K1_H2_012A_QUE, F_H2_012A_QUE
  ! ...as well as coefficients of the polynomial
  ! eg. H2_012A_QUE -> a0_LIN_H2_012A_QUE and a1_LIN_H2_012A_QUE
  K1_MagName = ( a0_LIN_MagName +a1_LIN_MagName*abs(I_MagName) ) /biro *abs(F_MagName);
  if (I_MagName<0){ K1_MagName=-K1_MagName; };
};

! convert current into K1, using a fifth order polynomial
I2K_QUs_fifth(MagName,biro) : macro {
  ! the macro expects IMagName, KMagName and FMagName to be defined
  ! eg. H2_012A_QUE -> I_H2_012A_QUE, K1_H2_012A_QUE, F_H2_012A_QUE
  ! ...as well as coefficients of the polynomial
  ! eg. H2_012A_QUE -> a0_FIF_H2_012A_QUE, a1_FIF_H2_012A_QUE, ... and a5_FIF_H2_012A_QUE
  if (I_MagName<0){
    K1_MagName:=-( a0_FIF_MagName
                  +a1_FIF_MagName*abs(I_MagName)
                  +a2_FIF_MagName*abs(I_MagName)^2
                  +a3_FIF_MagName*abs(I_MagName)^3
                  +a4_FIF_MagName*abs(I_MagName)^4
                  +a5_FIF_MagName*abs(I_MagName)^5) /biro *abs(F_MagName);
  }else{
    K1_MagName:=+( a0_FIF_MagName
                  +a1_FIF_MagName*abs(I_MagName)
                  +a2_FIF_MagName*abs(I_MagName)^2
                  +a3_FIF_MagName*abs(I_MagName)^3
                  +a4_FIF_MagName*abs(I_MagName)^4
                  +a5_FIF_MagName*abs(I_MagName)^5) /biro *abs(F_MagName);
  };
};

! duplicate an existing sequence
duplicateSequence(SeqInName,SeqOutName): macro {
    SeqOutName_L=SeqInName_L;
    SeqOutName: sequence, l=SeqOutName_L, refer=entry;
	SeqInName, at=0;
	endsequence;
};

! concatenate two existing sequences
concatenate2Sequences(SeqInName1,SeqInName2,SeqOutName): macro {
    SeqOutName_L=SeqInName1_L+SeqInName2_L;
    SeqOutName: sequence, l=SeqOutName_L, refer=entry;
	SeqInName1, at=0;
	SeqInName2, at=SeqInName1_L;
	endsequence;
};
